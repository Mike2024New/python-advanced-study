users_list = [
    {"name": "Ivan", "family": "Ivanow"},
    {"name": "Anna", "family": "Cholopova"},
    {"name": "Maxim", "family": "Petrow"},
    {"name": "Vasiliy", "family": "Smirnow"},
    {"name": "Egor", "family": "Nofamily"},
    {"name": "Nastya", "family": "Europina"},
]  # имитация базы данных допустим это якобы sqlite

rows_in_base = len(users_list)  # допустим мы получили кол-во строк запросом из sql


def get_users(count):
    """
    эта функция имитирует загрузчик записей из БД
    :param count: размер выдваемой порции данных (количество записей из псевдо БД)
    :return:
    """
    i = 0
    while i < rows_in_base:
        yield users_list[i:i + count]  # имитация получения польз из Базы Данных (берем только часть записей)
        i += count
    print('Все данные были просмотрены')  # в этой точке выполняется действие после завершения работы генератора


if __name__ == '__main__':
    """
    представим, что это иммитация примера где пользователь на странице сайта приложения, нажимает конопку показать еще
    товары (в примере показано показать ещё 2), и вот представим, что данных может быть не 2 строки а 200000 строк, так
    вот если все 200000 (это всего товаров) строк выгрузить в память, то приложение начнёт тупить и будет занято много
    памяти, вместо этого, по маленьку словно черпаком из БД будут выгружаться небольшие порции данных и таким образом
    в оперативной памяти хранится всего две записи (это в текущем примере), что значительно уменьшает кол-во занятой
    памяти.  
    """
    users = get_users(count=2)  # пусть это тока получения пользователей из БД через get_users

    for user in users:
        input("показать ещё пользователей, нажмите enter:")  # имитация кнопки показать ещё пользователей
        print(user)  # польз нажал кнопку показ следующих 2 пользов, -> выполнился запрос на след двух в базе
